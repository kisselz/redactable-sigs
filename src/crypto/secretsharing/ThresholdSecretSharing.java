/*
 *   Policy-Based Redactable Set Signature Schemes
 *   Copyright (C) 2022  Zachary A. Kissel
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package crypto.secretsharing;

import util.math.FieldFactory;
import util.Pair;
import util.math.Field;
import java.math.BigInteger;
import java.util.ArrayList;

/**
 * This implements Shamir's Threshold Secret sharing scheme from
 *            "How to Share a Secret" by Adi Shamir
 * Our construction allows for the choice of an arbitrary field.
 *
 * @author Zach Kissel
 */
 public class ThresholdSecretSharing
 {
   private int threshold;
   private int numShares;
   private Field f;

   /**
    * Construct a new secret sharing scheme with the given threshold
    * and number of shares. This uses the default field, NIST FFDHE2048.
    * @param threshold the schemes threshold value.
    * @param numShares the number of shares to produce.
    */
   public ThresholdSecretSharing(int threshold, int numShares)
   {
     this(threshold, numShares, FieldFactory.getField("FFDHE2048"));
   }

   /**
    * Construct a new secret sharing scheme with the given threshold
    * and number of shares. The field to work is specifed by the user.
    * @param threshold the schemes threshold value.
    * @param numShares the number of shares to produce.
    * @param f the field to work in.
    */
   public ThresholdSecretSharing(int threshold, int numShares, Field f)
   {
     this.threshold = threshold;
     this.numShares = numShares;
     this.f = f;
   }

   /**
    * Generates the shares for secret {@code secret}.
    * @param secret the secret to share out.
    * @return a list of shares.
    */
   public ArrayList<BigInteger> generateShares(BigInteger secret)
   {
     ArrayList<BigInteger> coeff = new ArrayList<>();
     ArrayList<BigInteger> points = new ArrayList<>();

     // Sample  a random polynomial.
     for (int i = 0; i < threshold; i++)
      coeff.add(f.sampleElement());
     coeff.set(0, secret);

     // Evaluate the polynomial at each point from 1 to numShares.
     for (int i = 1; i <= numShares; i++)
        points.add(evalPoly(coeff, new BigInteger(Integer.toString(i))));

     return points;
   }

   /**
    * Generates a share of a secret (generated by this method).
    * @return a list of shares.
    */
   public ArrayList<BigInteger> generateShares()
   {
     return generateShares(f.sampleElement());
   }

   /**
    * Use Lagrange interpolation to find the polynomial that fits
    * the given points evaluating the polynomial at x = 0.
    * @param shares the shares to be used in the reconstruction.
    * @return the reconstructed secret.
    */
   public BigInteger reconstructSecret(ArrayList<Pair<BigInteger>> shares)
   {
     BigInteger value = BigInteger.ZERO;

     for (int i = 0; i < shares.size(); i++)
      value = f.add(value,
         f.multiply(evaluateLagrange(i, shares), shares.get(i).getSecond()));

     return value;
   }


   /*********************************************************
    *
    *       Private Methods
    *
    ********************************************************/

   /**
    * Evaluates the Lagrange polynomial for point {@code i} L_i at {@code x = 0}.
    * Note this is a straight forward implementation.
    * @param points an array list of x-y points
    * @param i the point associated with the Lagrange polynomial.
    * @return the value of L_i(0).
    */
    private BigInteger evaluateLagrange(int i, ArrayList<Pair<BigInteger>> points)
    {
      BigInteger numerator = BigInteger.ONE;
      BigInteger denom = BigInteger.ONE;

      for (int j = 0; j < points.size(); j++)
      {
        if (j != i)
        {
          numerator = f.multiply(numerator, f.findAddInverse(points.get(j).getFirst()));
          denom = f.multiply(denom, f.add(points.get(i).getFirst(),
              f.findAddInverse(points.get(j).getFirst())));
        }
      }

      return f.multiply(numerator, f.findMultInverse(denom));
    }

   /**
    * Uses Horner's rule to evaluate a polynomial at given {@code x} using
    * the coefficients {@code coeff}. All computations are done in field F.
    * @param coeff the list of polynomail coefficients.
    * @param x the value to evaluate the polynomail on.
    * @return the value of the polynomail on {@code x}.
    */
   private BigInteger evalPoly(ArrayList<BigInteger> coeff, BigInteger x)
   {
     BigInteger y = coeff.get(coeff.size() - 1);

     for (int i  = coeff.size() - 2; i >= 0; i--)
        y = f.add(f.multiply(x, y), coeff.get(i));

     return y;
   }
 }
